
public class Main {

    /*
      План занятия
      1) Классы
      2) Класс Object
      3) Массивы
      4) Повторение
     */

    /*
    Теория
    ООП - объектно-ориентированное программирование одна из парадигм программирования(самая популярная и мощная), подразумевает
    создание некого типа(класса), который будет шаблоном для решения задач. В типе могут хранится данных, например:
    возраст, вес и т.д. и операции, например: вывод данных на консоль, изменение данных и т.п.
    В ООП существует 4 основных принципа:
    1) Инкапсуляция - изоляция данных внутри класса
    2) Полиморфизм  - с древнегреческого переводится как многоформие - возможность создавать методы с одинаковыми названиями, но
    разными параметрами для решения похожих, но отличающихся задач
    3) Наследование - по аналогии с юриспруденцией или биологией наследование - это возможность передавть свойство класса
    от родителя потомку
    4) Абстракция - это способ представления в коде объектов реального мира, например, у человека существует множество
    параметров и функций, но в нашей программе нужны только 3 его параметра и одна функция: вес, имя, рост и хождение, поэтому
    мы абстрактно запрограммируем человека только с этим набором атрибутов

    В Java существует класс Object - это класс, который является родителем для всех Java классов, таким образом разработчики
    языка гарантировали наличие определенного функционала у любого программиста.

    Если возникает ситуация, когда Вы получили метод по наследству, но Вам нужно изменить его поведение, в таком случае в
    своем классе Вы просто пишите имя метода и требуем функционал для Вашего класса поведение метода изменится. Такой
    прием называется переопределением

    Переопределенные методы принято помечать аннотацией @Override. На данный момент можете рассматривать их как комментарий,
    указывающий на то, что метод был переопределен

    Сортировка - упорядочивание чего либо по возрастанию или убыванию

    Простейшая сортировка - сортировка пузырьком(Bubble sort)

    Сортировка пузырьком подразумевает сравнение каждого элемента с каждым элементом и сдвиг этого элемента в зависимости
    от результата сравнения, таким образом элемент продвигается по массив подобно пузырьку воздуха в воде

     */

    /*
    Заметки
    В коде нет необходимости как либо указывать наследование от класса Object, любой класс является его потомком и измнеить
    это нельзя.

    Сортировка пузырьком имеет квадратичную сложноть, т.е. ее неэффективно использовать для больших структур, рекомендуется
    использование данной сортировки для структур имеющих не более 10 элементов, допустимо использовать данную сортировку для
    структур не превышающих 1000 элементов
     */

    /*
    Задачи со звездочкой
    1) Сделать свою реализацию методов ArrayList
     */

    public static void main(String[] args) {
        Car car1 = new Car(10000, 100, "Volkswagen");
        Car car2 = new Car(10000, 100, "Volkswagen");

        System.out.println(car1 == car2);
        System.out.println(car1.equals(car2));

        /*
        Задача
        Разработать класс для управления массивом.
        Реализовать методы: вставки, удаления, сортировки и поиска по массиву
        Решение
        1) Создадим класс
        2) Создадим массив из 10 элементов
        3) Создадим переменную для счета уже добавленных элементов
        4) Реализация методов
         */

        ArrayWorking array = new ArrayWorking(); // Если не определен консруктор в классе, то Java вызывает пустой конструктор для создания объекта
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        array.insert(5);
        array.insert(2);
        array.insert(1);
        array.insert(7);
        System.out.println(array.toString());
        array.delete(1);
        System.out.println(array.toString());
        System.out.println(array.find(3));
        array.sort();
        System.out.println(array.toString());
        System.out.println("Массив после удаления: ");
        array.clear();
        System.out.println(array.toString());
        System.out.println("Массив после взлома: ");
        array.hack();
        System.out.println(array.toString());
        System.out.println("Массив после стирания: ");
        array.erase();
        System.out.println(array.toString());
        System.out.println("Массив после взлома: ");
        array.hack();
        System.out.println(array.toString());


    }




}
